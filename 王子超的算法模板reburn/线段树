//线段树

ll A[maxn];

struct Node
{
    ll l,r,data,ope;
};

Node st[4*maxn];

void build(ll l,ll r,ll loca)
{
    st[loca].l=l;
    st[loca].r=r;
    st[loca].ope=0;
    if(l==r) st[loca].data=1;
    else
    {
        ll mid=(l+r)>>1;
        build(l,mid,loca<<1);
        build(mid+1,r,(loca<<1)+1);
        st[loca].data=l-r+1;
    }
}

void spread(ll loca)
{
    if(st[loca].ope)
    {
        st[loca<<1].data=st[loca].ope*(st[loca<<1].r-st[loca<<1].l+1);
        st[(loca<<1)+1].data=st[loca].ope*(st[(loca<<1)+1].r-st[(loca<<1)+1].l+1);
        st[loca<<1].ope=st[loca].ope;
        st[(loca<<1)+1].ope=st[loca].ope;
        st[loca].ope=0;
    }
}

void change(ll l,ll r,ll loca,ll ope)
{
    if(st[loca].l>=l&&st[loca].r<=r)
    {
        st[loca].data=ope*(st[loca].r-st[loca].l+1);
        st[loca].ope=ope;
        return;
    }
    spread(loca);
    ll mid=(st[loca].r+st[loca].l)>>1;
    if(l<=mid) change(l,r,loca<<1,ope);
    if(r>mid) change(l,r,(loca<<1)+1,ope);
    st[loca].data=st[loca<<1].data+st[(loca<<1)+1].data;
}

ll ask(ll l,ll r,ll loca)
{
    if(st[loca].l>=l&&st[loca].r<=r) return st[loca].data;
    spread(loca);
    ll mid=(st[loca].l+st[loca].r)>>1;
    ll temp=0;
    if(l<=mid) temp+=ask(l,r,loca<<1);
    if(r>mid) temp+=ask(l,r,(loca<<1)+1);
    return temp;
}